\documentclass[10pt]{report}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\geometry{a4paper, margin=0.3in}


\begin{document}
\begin{lstlisting}[language=C++, caption=Original code listing]
int main(int argc, char* argv[]) {
    int nx(10000), ny(200), nt(200);        
    double** vi=new double*[nx];
    double** vr=new double*[nx];
    double pi=(4.*atan(1.));        Constant here? Could use M_PI 
                                    Direct initialization?

    for(int i=0;i<nx;i++) {         Should probably change the operation order 
        vi[i]=new double[ny];       here with the self incrementation ie. ++i
        vr[i]=new double[ny];       instead of ++i. 
    }
                                    Cache thrashing? Try offsetting
    for(int i=0;i<nx;i++) {         the memory access pattern 
        for(int j=0;j<ny;j++) {       
            vi[i][j]=double(i*i)*double(j)*sin(pi/double(nx)*double(i));  
            vr[i][j]=0.;     
        }                   We should calculate constants outside of the loop
    }

    ofstream fout("data_out");

    for(int t=0;t<nt;t++) {
        cout<<"\n"<<t;cout.flush();
        for(int i=0;i<nx;i++) {             Relies heavily on branching 'if' conditionals
            for(int j=0;j<ny;j++) {             Redundant conditions can be simplified
                if(i>0&&i<nx-1&&j>0&&j<ny-1) {
                    vr[i][j]=(vi[i+1][j]+vi[i-1][j]+vi[i][j-1]+vi[i][j+1])/4.;
                } else if(i==0&&i<nx-1&&j>0&&j<ny-1) {
                    vr[i][j]=(vi[i+1][j]+10.+vi[i][j-1]+vi[i][j+1])/4.;
                } else if(i>0&&i==nx-1&&j>0&&j<ny-1) {                 
                    vr[i][j]=(5.+vi[i-1][j]+vi[i][j-1]+vi[i][j+1])/4.;
                } else if(i>0&&i<nx-1&&j==0&&j<ny-1) {
                    vr[i][j]=(vi[i+1][j]+vi[i-1][j]+15.45+vi[i][j+1])/4.;
                } else if(i>0&&i<nx-1&&j>0&&j==ny-1) {
                    vr[i][j]=(vi[i+1][j]+vi[i-1][j]+vi[i][j-1]-6.7)/4.;
                }
            }
        }

        for(int i=0;i<nx;i++) {             Can be simplified to a single loop
            for(int j=0;j<ny;j++) {         
                if(fabs(fabs(vr[i][j])-fabs(vi[i][j]))<1e-2) fout<<"\n"
                <<t<<" "<<i<<" "<<j<<" "
                <<fabs(vi[i][j])<<" "<<fabs(vr[i][j]);
            }
        }                                   Repeated, unnecessary calls to fabs() 
                                            can be avoided by storing the value

        for(int i=0;i<nx;i++) {
            for(int j=0;j<ny;j++) vi[i][j]=vi[i][j]/2.+vr[i][j]/2.;      
        }                                                                 
    }               Again we can append this to the                  
}                   previous loop, also change division
                    to multiplication by 0.5
\end{lstlisting}
\vspace{1cm}
As well as the general bad practice shown in the above block it is clear that no cache awareness has influenced the design and structure of the code. Repeated unnecessary function calls, cache thrashing and redundant branching all contributes to the degredation of the performance of the code. The following block of code shows my attempt at addressing these issues as well as anything else I may have spotted.



\newpage
\begin{lstlisting}[language=C++, caption=Optimized code listing]
#include <iostream>
#include <fstream>
#include <math.h>
#include <cstring>
#include <sys/time.h>

using namespace std;

struct allData { 
double** vi;
double** vr;
const double pi_over_nx = M_PI/double(nx);

int i, j, t;

static constexpr double dividebyfour = 0.25;
static constexpr double dividebytwo = 0.5;
static constexpr int nx = 10000;
static constexpr int ny = 200;
static constexpr int nt = 200;

allData() {
        vi = new double*[nx];
        vr = new double*[nx];
        for(i=0;i<nx;++i) {
                vi[i]=new double[ny];                                    
                vr[i]=new double[ny];
        }
}

~allData() {
        for(i=0;i<nx;++i) {
                delete[] vi[i];
                delete[] vr[i];
        }
        delete[] vi;
        delete[] vr;
}

};

struct timeval start, endTime;

int main(int argc, char* argv[]) {

gettimeofday(&start, NULL);
allData data;

for(data.i=0;data.i<data.nx;++data.i) {
const double constant(double(data.i*data.i)*sin(data.pi_over_nx*double(data.i)));
for(data.j=0;data.j<data.ny;++data.j) {
    data.vi[data.i][data.j]= constant * double(data.j);         
    data.vr[data.i][data.j] = 0;
    }
}

ofstream fout("data_out");
                
for(data.t=0;data.t<data.nt;++data.t) {                                               
                                                                                
cout<<"\n"<<data.t;cout.flush();                                          

for(data.i=1;data.i<data.nx-1;++data.i) {
    data.vr[data.i][0]=(data.vi[data.i+1][0]+data.vi[data.i-1][0]+
                        15.45+data.vi[data.i][1])*data.dividebyfour;
    data.vr[data.i][199]=(data.vi[data.i+1][199]+
                          data.vi[data.i-1][199]+
                          data.vi[data.i][198]-6.7)*data.dividebyfour;
}
for(data.i=1;data.i<data.nx-1;++data.i) {
    for(data.j=1;data.j<data.ny-1;data.j++) {
        data.vr[data.i][data.j]=(data.vi[data.i+1][data.j]+
                                data.vi[data.i-1][data.j]+
                                data.vi[data.i][data.j-1]+
                                data.vi[data.i][data.j+1])*data.dividebyfour;
    }
}
for(data.j=1;data.j<data.ny-1;++data.j) {
    data.vr[0][data.j]=(data.vi[1][data.j]+10.+data.vi[0][data.j-1]+
                        data.vi[0][data.j+1])*data.dividebyfour;
    data.vr[9999][data.j]=(5.+data.vi[9998][data.j]+
                           data.vi[9999][data.j-1]+
                           data.vi[9999][data.j+1])*data.dividebyfour;
}
                
for(data.i=0;data.i<data.nx;++data.i) {

for(data.j=0;data.j<data.ny;++data.j) {                                 
    const double valvr(fabs(data.vr[data.i][data.j]));
    const double valvi(fabs(data.vi[data.i][data.j]));
    if(fabs(valvr-valvi)<1e-2) 
    fout<<"\n"<<data.t<<" "<<data.i<<" "<<data.j<<" "<<valvi<<" "<<valvr;
 
    data.vi[data.i][data.j]=(data.vi[data.i][data.j]*
    data.dividebytwo)+(data.vr[data.i][data.j]*data.dividebytwo);
        }
    }
}
gettimeofday(&endTime, NULL);
cout << "\nTime taken = " << ((endTime.tv_sec - start.tv_sec) +
         (endTime.tv_usec - start.tv_usec) / 1e6) << " seconds";
}
\end{lstlisting}




\end{document}